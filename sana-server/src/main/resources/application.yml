# Tomcat
server:
  port: 28081
  servlet:
    context-path: /sana
    session:
      cookie:
        http-only: true
spring:
  # 环境 dev|test|prod
  profiles:
    active: prod
  application:
    name: sana
  jackson:
    time-zone: GMT+8
  servlet:
    multipart:
      enabled: true
      max-file-size: 40MB
      max-request-size: 40MB
  # 任务调度
  quartz:
    job-store-type: "jdbc"    # 任务存储类型
    wait-for-jobs-to-complete-on-shutdown: false    # 关闭时等待任务完成
    overwrite-existing-jobs: true   # 是否覆盖已有的任务
    auto-startup: true    # 是否自动启动计划程序
    startup-delay: 0s   # 延迟启动
    jdbc:
      initialize-schema: "never"  # 数据库架构初始化模式（never：从不进行初始化；always：每次都清空数据库进行初始化；embedded：只初始化内存数据库（默认值））
    properties: # 相关属性配置
      org:
        quartz:
          scheduler:
            instanceName: SanaScheduler # 调度器实例名称
            instanceId: AUTO  # 分布式节点ID自动生成
          jobStore:
            class: org.springframework.scheduling.quartz.LocalDataSourceJobStore
            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate
            tablePrefix: QRTZ_  # 表前缀
            isClustered: false  # 是否开启集群
            dataSource: quartz  # 数据源别名（自定义）
            clusterCheckinInterval: 10000 # 分布式节点有效性检查时间间隔（毫秒）
            useProperties: false
          # 线程池配置
          threadPool:
            class: org.quartz.simpl.SimpleThreadPool
            threadCount: 10
            threadPriority: 5
            threadsInheritContextClassLoaderOfInitializingThread: true
sana:
  version: '@project.version@'
  resetPassword: 'sana.password' #重置密码功能中默认要修改的密码
  logging-enabled: true #是否开启日志存储（如果关闭，则不会进行日志数据的存储）
  logging-save-type: mysql #日志存储类型（tdengine\mysql）
  devicedata-enabled: true  #是否开启设备数据存储
  log-save-speed: 20  # 日志每次存储条数(建议根据实际配置、实际操作数量修改)
  device-data-speed: 20  # 设备存储每次存储条数（建议根据实际配置、实际操作数量修改）
  aviator-path:  #aviator规则脚本存储位置，如果不设置，则默认为当前程序运行的目录下的：/sana-rules/src/main/resources/script中
  rule-priority: listening  #(timing\listening)  #规则优先，定时：timing，监听：listening。这里要特别说明一下：如果设置为timing，则定时优先，如果是listening，则监听优先（这种情况发生在同一个设备同时属于定时、监听规则的情况下，并且在相同时间内触发，选择性的执行哪一个）
  rule-action:  #rule配置
    queue-type:  REDIS  # 队列类型(REDIS：已实现,KAFKA:暂无实现，或将放在后期)
    core-size: 2        # 线程池大小
    queue-capacity: 500 # 队列大小
  general-prefix:
    table-prefix: 'sb'               # 客户端id前缀（mqtt客户端连接的clientId前缀，需要遵守：’前缀‘+’设备id‘，设备id就是设备实例的id。子表、客户端id、以及规则映射关系，也和这个相关）
    device-topic-prefix: '/SB/'      # 设备主题前缀（只监听和接受以该前缀的设备消息，需要遵守：’前缀‘+’设备id‘，设备id就是设备实例的id）
    proxy-prefix: '/SB/'            # 代理前缀（本系统会使用mqtt客户端，订阅该前缀的主题。需要注意的是，在设备侧配置topic的时候，需要用这种格式：’/SB/‘+'设备id'。这样才能收到）
    proxy-status: '/SBSTUTA'         # 代理设备状态前缀（使用代理mqtt的时候，本系统会订阅这个主题。用于同步设备的上下线操作。以使用的emqx为例，则需要配置一条上下线的规则，转发到该主题上来）

mybatis-plus:
  mapper-locations: classpath*:/mapper/**/*.xml
  typeAliasesPackage: com.sana.*.entity
  global-config:
    db-config:
      id-type: AUTO
      logic-delete-value: 1
      logic-not-delete-value: 0
    banner: false
  configuration:
    map-underscore-to-camel-case: true
    cache-enabled: false
    call-setters-on-nulls: true
    jdbc-type-for-null: 'null'
  configuration-properties:
    prefix:
    blobType: BLOB
    boolValue: TRUE
